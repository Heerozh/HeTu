# HeTu配置文件模板

# 你的游戏服务器端代码文件，也就是System和Component的定义
APP_FILE: app.py

# 项目名称，也代表加载app_file中的哪个namespace
NAMESPACE: game_short_name

# 服务器实例名称，每个实例是一个副本，同一台服务器上可启动多个副本。
# 客户端SDK可以选择登录哪个副本。
INSTANCES:
  - nanjing-server1
  - nanjing-server2

# 开启服务器的debug模式，打印debug消息，并且自动生成调试用的https证书
DEBUG: false
# 开启web控制后台，GET /获得信息 POST /reload重载代码 POST /shutdown关闭服务器
#INSPECTOR: true
#INSPECTOR_PORT: 6457

# 前置反向代理的数量。用于获取真实IP，host等，一般为1，除非是多级代理
PROXIES_COUNT: 1

# SSL配置，推荐用反向代理caddy，而不要这里弄
#CERT_CHAIN:
#  - null  # 第一个设null禁止通过IP查看证书
#  - cert: /path/to/example.com/fullchain.pem
#    key: /path/to/example.com/privkey.pem
#    password: 可选，如果密钥有密码的话
#  - cert: /path/to/example2.cn/fullchain.pem
#    key: /path/to/example2.cn/privkey.pem
#    password: 可选，如果密钥有密码的话

# 服务器Websocket监听地址
LISTEN: 0.0.0.0:2466

# 工作进程数，-1 为自动按cpu核心数
WORKER_NUM: 4

# 反正是Websocket，可以关了加性能
ACCESS_LOG: false

# 传入消息的最大字节、ping间隔秒、ping无响应关闭连接秒
# !eval表示返回后面中括号内的代码执行结果
WEBSOCKET_MAX_SIZE: !eval [ 2 ** 19 ] # 0.5MB
# WEBSOCKET_PING_INTERVAL = 20
# WEBSOCKET_PING_TIMEOUT = 20

# 闲置多少秒未调用System/Endpoint则视为断线
ENDPOINT_CALL_IDLE_TIMEOUT: !eval [ 60 * 2 ]
# 限制每个IP可以创建多少匿名连接（提权登陆后不受此限制）
MAX_ANONYMOUS_CONNECTION_BY_IP: 10

# 限制未登录客户端发送消息的频率，可以设置多个指标，格式为[最大数量，统计时间（秒）]，默认值意思是限制每秒1条消息
# elevate(登录提权)会把此限制次数*10，如需自定义，可在任意System中修改 ctx.client_limits 值
CLIENT_SEND_LIMITS:
  - [ 10, 1 ]
  - [ 27, 5 ]
  - [ 100, 50 ]
  - [ 300, 300 ]
# 限制服务器端发送给未登录客户端消息的频率，格式同上
SERVER_SEND_LIMITS:
  - [ 10, 1 ]
  - [ 27, 5 ]
  - [ 100, 50 ]
  - [ 300, 300 ]
# 限制未登录客户端最大允许订阅的行数。每次 HeTuClientSDK.get 算1行；HeTuClientSDK.range 按返回的行数计入。
# elevate(登录提权)会把此限制次数*50，或自己在任意System中修改 ctx.max_row_sub 值，不宜超过1000
MAX_ROW_SUBSCRIPTION: 10
# 限制未登录客户端最大允许订阅的Index数(HeTuClientSDK.range)。每次range订阅+1。
MAX_INDEX_SUBSCRIPTION: 1

# 消息流处理层，可以设置多层，按照顺序处理。
# 如需自定义层，只要继承自hetu.server.pipeline.MessageProcessLayer，并定义alias，即可在这添加
PACKET_LAYERS:
  # 添加消息json to bytes序列化层
  - type: jsonb
  # 开启消息zlib流式压缩
  # 速度：zstd_lv3 422k/s > zlib_lv1 357k/s > brotli_lv3 100k/s
  # 压缩率 zlib_lv1 25% > brotli_lv3 25% > zstd_lv3 23%
  # 因为hetu zlib可以预编字典，所以压缩率很高，使得其他压缩算法优势不明显。
  # 目前只支持zlib，因为其他的在 unity 上只能跑支持native插件的平台。
  # todo OpenZL
  - type: zlib
    level: 1  # 因为有字典，级别1以上压缩率无明显提升
  # 消息加密层，使用ChaCha20-Poly1305算法
  - type: crypto
    password: your_password_here  # 加密签名密钥，客户端必须有相同密钥才能连接服务器


# 后端数据库地址，component中的backend可以指定用这里的哪个后端
BACKENDS:
  # 第一条是默认后端。@define_component不指定backend时会用这个
  your_backend_name:
    # 指定backend的类型，目前只支持Redis
    type: Redis
    # 指定master服务器，只能一个地址
    # 如果河图在容器内启动，访问宿主机ip可用host.docker.internal
    # Redis: url格式：redis://[[username]:[password]]@localhost:6379/0
    #        要求Redis >= 7.0。但广泛兼容Forks: Valkey, Tair等；支持redis代理层。
    master: redis://127.0.0.1:6379/0
    # 开启Hetu内置的读写分离模式，填写只读副本服务器的url们。
    # 读分为 事务读、和订阅读；事务读会在主服务器和servants中按权重选择，
    # 订阅读，就是客户端SDK的数据订阅，永远只在随机servants上进行。
    # Redis:
    #  - redis下，servant就是只读replica服务器
    #  - 开启redis原生集群模式的无需填写此项，可自动生效，因为原生集群会自动加载replica地址
    #  - 开启redis proxy代理层的无法填写此项，因为读写分离已经由proxy负责
    servants: [ ]
    # 主数据库事务读权重。提高此值减少事务冲突概率，降低此值减少主数据库事务读负载
    # 只在填写了servants时有效，每台servant的读权重固定为1，
    master_weight: 1.0
    # 指出Redis后端是原生集群模式。不建议使用此项，而是加一层redis proxy代理层，由它控制分片和集群。
    # 河图天然支持分片，所有的key都带有Redis协议的Hash tags，自动根据System的component定义，计算
    # 数据隔离，把隔离的数据分配到不同的分片上，提升写入性能。
    # 只有在master写入负载过高时再考虑集群，因为读负载全可通过servants分担，文档有全面的负载压测数据。
    raw_clustering: false

# 配置日志，格式https://docs.python.org/3/library/logging.config.html
LOGGING:
  version: 1
  disable_existing_loggers: false

  loggers:
    root: # 根日志记录器，所有未被过滤掉的日志都会经过这里
      level: DEBUG # 接受日志级别，生产用INFO
      handlers: # 输出目标，这里输出到进程安全的log_queue，这样可以把多进程的日志合并到一起
        - log_queue
    HeTu.root: # 河图的日志记录器
      level: DEBUG
    HeTu.replay: # replay日志记录器，用于回放复现BUG，level为DEBUG起效，设为ERROR完全关闭。
      level: DEBUG
      propagate: false # 不向上级传递，不然会传递给root
      handlers:
        - replay_queue

  filters:
    add_context: # 生成ctx信息的filter
      (): hetu.safelogging.filter.ContextFilter

  handlers: # 处理器创建，用来决定日志的输出方式
    console: # 控制台输出
      class: logging.StreamHandler
      formatter: colour
      stream: ext://sys.stdout
    log_to_file: # 输出到按日期切割的文件，不可直接输入到这里，因为不是进程安全的
      class: logging.handlers.TimedRotatingFileHandler
      formatter: generic
      filename: logs/hetu.log
      encoding: utf-8
      delay: true
      when: D
      interval: 1
      backupCount: 30
    replay_to_file: # 输出到按大小切割的文件，不可直接输入到这里，因为不是进程安全的
      class: logging.handlers.RotatingFileHandler
      formatter: generic
      filename: logs/replay.log
      encoding: utf-8
      delay: true
      maxBytes: !eval [ 2 ** 28 ] # 256MB
      backupCount: 20 # 20 * 256MB = 5GB
    #    syslog:  # 也可以用syslog输出
    #      class: logging.handlers.SysLogHandler
    #      formatter: generic
    #      address: /dev/log
    #      facility: local0
    log_queue: # 进程安全的queue
      class: logging.handlers.QueueHandler
      filters: # 如果要生成ctx信息(formatters里%(ctx))，需要加这个filter。只能加在QueueHandler上
        - add_context
      queue: hetu.safelogging.handlers.process_safe_queue
      listener: hetu.safelogging.handlers.AutoListener # 定义消费器，AutoListener会自动启动和停止
      handlers: # 消费此queue的handler
        - console
        - log_to_file
    replay_queue:
      class: logging.handlers.QueueHandler
      filters:
        - add_context # 如果要生成ctx信息，需要加这个filter
      queue: hetu.safelogging.handlers.process_safe_queue
      listener: hetu.safelogging.handlers.AutoListener
      handlers:
        - replay_to_file

  formatters:
    colour: # 彩色格式
      class: sanic.logging.formatter.AutoFormatter
    generic: # 文本格式
      format: "%(ident)s %(asctime)s %(levelname)-8s %(name)-12s %(ctx)-27s %(message)s"
      datefmt: "%Y-%m-%d %H:%M:%S %z"
